{
  "ebookshoppe_uk": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 1 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nimport urllib2\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass EBookShoppeUKStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        url_details = 'http://www.awin1.com/cread.php?awinmid=1414&awinaffid=120917&clickref=&p={0}'\n        url = 'http://www.awin1.com/awclick.php?mid=2666&id=120917'\n\n        if external or self.config.get('open_external', False):\n            if detail_item:\n                url = url_details.format(detail_item)\n            open_url(QUrl(url))\n        else:\n            detail_url = None\n            if detail_item:\n                detail_url = url_details.format(detail_item)\n            d = WebStoreDialog(self.gui, url, parent, detail_url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=10, timeout=60):\n        url = 'http://www.ebookshoppe.com/search.php?search_query=' + urllib2.quote(query)\n        br = browser()\n        br.addheaders = [(\"Referer\", \"http://www.ebookshoppe.com/\")]\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n            for data in doc.xpath('//ul[@class=\"ProductList\"]/li'):\n                if counter <= 0:\n                    break\n\n                id = ''.join(data.xpath('./div[@class=\"ProductDetails\"]/'\n                                        'strong/a/@href')).strip()\n                if not id:\n                    continue\n                cover_url = ''.join(data.xpath('./div[@class=\"ProductImage\"]/a/img/@src'))\n                title = ''.join(data.xpath('./div[@class=\"ProductDetails\"]/strong/a/text()'))\n                price = ''.join(data.xpath('./div[@class=\"ProductPriceRating\"]/em/text()'))\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url\n                s.title = title.strip()\n                s.price = price\n                s.drm = SearchResult.DRM_UNLOCKED\n                s.detail_item = id\n\n                self.get_author_and_formats(s, timeout)\n                if not s.author:\n                    continue\n\n                yield s\n\n    def get_author_and_formats(self, search_result, timeout):\n        br = browser()\n        with closing(br.open(search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            author = ''.join(idata.xpath('//div[@id=\"ProductOtherDetails\"]/dl/dd[1]/text()'))\n            if author:\n                search_result.author = author\n            formats = idata.xpath('//dl[@class=\"ProductAddToCart\"]/dd/'\n                                  'ul[@class=\"ProductOptionList\"]/li/label/text()')\n            if formats:\n                search_result.formats = ', '.join(formats)\n            search_result.drm = SearchResult.DRM_UNKNOWN\n        return True\n", 
  "smashwords": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 2 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nimport random\nimport re\nimport urllib2\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass SmashwordsStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        url = 'http://www.smashwords.com/'\n\n        aff_id = '?ref=usernone'\n        # Use Kovid's affiliate id 30% of the time.\n        if random.randint(1, 10) in (1, 2, 3):\n            aff_id = '?ref=kovidgoyal'\n\n        detail_url = None\n        if detail_item:\n            detail_url = url + detail_item + aff_id\n        url = url + aff_id\n\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner(detail_url if detail_url else url)))\n        else:\n            d = WebStoreDialog(self.gui, url, parent, detail_url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=10, timeout=60):\n        url = 'http://www.smashwords.com/books/search?query=' + urllib2.quote(query)\n\n        br = browser()\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n            for data in doc.xpath('//div[@id=\"pageCenterContent\"]//div[@class=\"library-book\"]'):\n                if counter <= 0:\n                    break\n                data = html.fromstring(html.tostring(data))\n\n                id = None\n                id_a = ''.join(data.xpath('//a[contains(@class, \"library-title\")]/@href'))\n                if id_a:\n                    id = id_a.split('/')[-1]\n                if not id:\n                    continue\n\n                cover_url = ''.join(data.xpath('//img[contains(@class, \"book-list-image\")]/@src'))\n\n                title = ''.join(data.xpath('.//a[contains(@class, \"library-title\")]/text()'))\n                author = ''.join(data.xpath('.//div[@class=\"subnote\"]//a[1]//text()'))\n\n                price = ''.join(data.xpath('.//div[@class=\"subnote\"]//text()'))\n                if 'Price:' in price:\n                    try:\n                        price = price.partition('Price:')[2]\n                        price = re.sub('\\s', ' ', price).strip()\n                        price = price.split(' ')[0]\n                        price = price.strip()\n                    except:\n                        price = 'Unknown'\n\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url\n                s.title = title.strip()\n                s.author = author.strip()\n                s.price = price.strip()\n                s.detail_item = '/books/view/' + id.strip()\n                s.drm = SearchResult.DRM_UNLOCKED\n\n                yield s\n\n    def get_details(self, search_result, timeout):\n        url = 'http://www.smashwords.com/'\n\n        br = browser()\n        with closing(br.open(url + search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            search_result.formats = ', '.join(list(set(idata.xpath('//p//abbr//text()'))))\n        return True\n", 
  "amazon": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 5 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nimport random\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.search_result import SearchResult\n\nclass AmazonKindleStore(StorePlugin):\n\n    search_url = 'http://www.amazon.com/s/?url=search-alias%3Ddigital-text&field-keywords='\n    details_url = 'http://amazon.com/dp/'\n    drm_search_text = u'Simultaneous Device Usage'\n    drm_free_text = u'Unlimited'\n\n    def open(self, parent=None, detail_item=None, external=False):\n        '''\n        Amazon comes with a number of difficulties.\n\n        QWebView has major issues with Amazon.com. The largest of\n        issues is it simply doesn't work on a number of pages.\n\n        When connecting to a number parts of Amazon.com (Kindle library\n        for instance) QNetworkAccessManager fails to connect with a\n        NetworkError of 399 - ProtocolFailure. The strange thing is,\n        when I check QNetworkRequest.HttpStatusCodeAttribute when the\n        399 error is returned the status code is 200 (Ok). However, once\n        the QNetworkAccessManager decides there was a NetworkError it\n        does not download the page from Amazon. So I can't even set the\n        HTML in the QWebView myself.\n\n        There is http://bugreports.qt.nokia.com/browse/QTWEBKIT-259 an\n        open bug about the issue but it is not correct. We can set the\n        useragent (Arora does) to something else and the above issue\n        will persist. This http://developer.qt.nokia.com/forums/viewthread/793\n        gives a bit more information about the issue but as of now (27/Feb/2011)\n        there is no solution or work around.\n\n        We cannot change the The linkDelegationPolicy to allow us to avoid\n        QNetworkAccessManager because it only works links. Forms aren't\n        included so the same issue persists on any part of the site (login)\n        that use a form to load a new page.\n\n        Using an aStore was evaluated but I've decided against using it.\n        There are three major issues with an aStore. Because checkout is\n        handled by sending the user to Amazon we can't put it in a QWebView.\n        If we're sending the user to Amazon sending them there directly is\n        nicer. Also, we cannot put the aStore in a QWebView and let it open the\n        redirection the users default browser because the cookies with the\n        shopping cart won't transfer.\n\n        Another issue with the aStore is how it handles the referral. It only\n        counts the referral for the items in the shopping card / the item\n        that directed the user to Amazon. Kindle books do not use the shopping\n        cart and send the user directly to Amazon for the purchase. In this\n        instance we would only get referral credit for the one book that the\n        aStore directs to Amazon that the user buys. Any other purchases we\n        won't get credit for.\n\n        The last issue with the aStore is performance. Even though it's an\n        Amazon site it's alow. So much slower than Amazon.com that it makes\n        me not want to browse books using it. The look and feel are lesser\n        issues. So is the fact that it almost seems like the purchase is\n        with calibre. This can cause some support issues because we can't\n        do much for issues with Amazon.com purchase hiccups.\n\n        Another option that was evaluated was the Product Advertising API.\n        The reasons against this are complexity. It would take a lot of work\n        to basically re-create Amazon.com within calibre. The Product\n        Advertising API is also designed with being run on a server not\n        in an app. The signing keys would have to be made avaliable to ever\n        calibre user which means bad things could be done with our account.\n\n        The Product Advertising API also assumes the same browser for easy\n        shopping cart transfer to Amazon. With QWebView not working and there\n        not being an easy way to transfer cookies between a QWebView and the\n        users default browser this won't work well.\n\n        We could create our own website on the calibre server and create an\n        Amazon Product Advertising API store. However, this goes back to the\n        complexity argument. Why spend the time recreating Amazon.com\n\n        The final and largest issue against using the Product Advertising API\n        is the Efficiency Guidelines:\n\n        \"Each account used to access the Product Advertising API will be allowed\n        an initial usage limit of 2,000 requests per hour. Each account will\n        receive an additional 500 requests per hour (up to a maximum of 25,000\n        requests per hour) for every $1 of shipped item revenue driven per hour\n        in a trailing 30-day period. Usage thresholds are recalculated daily based\n        on revenue performance.\"\n\n        With over two million users a limit of 2,000 request per hour could\n        render our store unusable for no other reason than Amazon rate\n        limiting our traffic.\n\n        The best (I use the term lightly here) solution is to open Amazon.com\n        in the users default browser and set the affiliate id as part of the url.\n        '''\n        aff_id = {'tag': 'josbl0e-cpb-20'}\n        # Use Kovid's affiliate id 30% of the time.\n        if random.randint(1, 10) in (1, 2, 3):\n            aff_id['tag'] = 'calibrebs-20'\n        store_link = 'http://www.amazon.com/Kindle-eBooks/b/?ie=UTF&node=1286228011&ref_=%(tag)s&ref=%(tag)s&tag=%(tag)s&linkCode=ur2&camp=1789&creative=390957' % aff_id\n        if detail_item:\n            aff_id['asin'] = detail_item\n            store_link = 'http://www.amazon.com/dp/%(asin)s/?tag=%(tag)s' % aff_id\n        open_url(QUrl(store_link))\n\n    def search(self, query, max_results=10, timeout=60):\n        url = self.search_url + query.encode('ascii', 'backslashreplace').replace('%', '%25').replace('\\\\x', '%').replace(' ', '+')\n        br = browser()\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n\n            if doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"grid\")]'):\n                data_xpath = '//div[contains(@class, \"prod\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './/img[contains(@class, \"productImage\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            elif doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"ilresults\")]'):\n                data_xpath = '//li[(@class=\"ilo\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './div[@class = \"ilf\"]/a/img[contains(@class, \"ilo\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                # Results can be in a grid (table) or a column\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltL\") or contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            elif doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"list\")]'):\n                data_xpath = '//div[contains(@class, \"prod\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltL\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './/img[contains(@class, \"productImage\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltL\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            else:\n                return\n\n            for data in doc.xpath(data_xpath):\n                if counter <= 0:\n                    break\n\n                # Even though we are searching digital-text only Amazon will still\n                # put in results for non Kindle books (author pages). Se we need\n                # to explicitly check if the item is a Kindle book and ignore it\n                # if it isn't.\n                format = ''.join(data.xpath(format_xpath))\n                if 'kindle' not in format.lower():\n                    continue\n\n                # We must have an asin otherwise we can't easily reference the\n                # book later.\n                asin = data.xpath(asin_xpath)\n                if asin:\n                    asin = asin[0]\n                else:\n                    continue\n\n                cover_url = ''.join(data.xpath(cover_xpath))\n\n                title = ''.join(data.xpath(title_xpath))\n                author = ''.join(data.xpath(author_xpath))\n                try:\n                    author = author.split('by ', 1)[1].split(\" (\")[0]\n                except:\n                    pass\n\n                price = ''.join(data.xpath(price_xpath))\n\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url.strip()\n                s.title = title.strip()\n                s.author = author.strip()\n                s.price = price.strip()\n                s.detail_item = asin.strip()\n                s.formats = 'Kindle'\n\n                yield s\n\n    def get_details(self, search_result, timeout):\n        url = self.details_url\n\n        br = browser()\n        with closing(br.open(url + search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            if idata.xpath('boolean(//div[@class=\"content\"]//li/b[contains(text(), \"' +\n                           self.drm_search_text + '\")])'):\n                if idata.xpath('boolean(//div[@class=\"content\"]//li[contains(., \"' +\n                               self.drm_free_text + '\") and contains(b, \"' +\n                               self.drm_search_text + '\")])'):\n                    search_result.drm = SearchResult.DRM_UNLOCKED\n                else:\n                    search_result.drm = SearchResult.DRM_UNKNOWN\n            else:\n                search_result.drm = SearchResult.DRM_LOCKED\n        return True\n", 
  "kobo": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 3 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nimport random\nimport urllib\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass KoboStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        pub_id = 'sHa5EXvYOwA'\n        # Use Kovid's affiliate id 30% of the time.\n        if random.randint(1, 10) in (1, 2, 3):\n            pub_id = '0dsO3kDu/AU'\n\n        murl = 'http://click.linksynergy.com/fs-bin/click?id=%s&subid=&offerid=280046.1&type=10&tmpid=9310&RD_PARM1=http%%3A%%2F%%2Fkobo.com' % pub_id\n\n        if detail_item:\n            purl = 'http://click.linksynergy.com/link?id=%s&offerid=280046&type=2&murl=%s' % (pub_id, urllib.quote_plus(detail_item))\n            url = purl\n        else:\n            purl = None\n            url = murl\n\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner(url)))\n        else:\n            d = WebStoreDialog(self.gui, murl, parent, purl)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=10, timeout=60):\n        url = 'http://www.kobobooks.com/search/search.html?q=' + urllib.quote_plus(query)\n\n        br = browser()\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n            for data in doc.xpath('//ul[contains(@class, \"flowview-items\")]/li'):\n                if counter <= 0:\n                    break\n\n                id = ''.join(data.xpath('./a[contains(@class, \"block-link\")]/@href'))\n                if not id:\n                    continue\n                id = id[1:]\n\n                price = ''.join(data.xpath('.//a[contains(@class, \"primary-button\")]//text()'))\n\n                cover_url = ''.join(data.xpath('.//img[1]/@src'))\n                cover_url = 'http:%s' % cover_url\n\n                title = ''.join(data.xpath('.//p[contains(@class, \"flowview-item-title\")]//text()'))\n\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url\n                s.title = title.strip()\n                s.price = price.strip()\n                s.detail_item = 'http://store.kobobooks.com/' + id.strip()\n                s.formats = 'EPUB'\n                s.drm = SearchResult.DRM_UNKNOWN\n\n                yield s\n\n    def get_details(self, search_result, timeout):\n        br = browser()\n        with closing(br.open(search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            search_result.author = ', '.join(idata.xpath('.//h2[contains(@class, \"author\")]//a/text()'))\n        return True\n", 
  "legimi": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 5 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011-2014, Tomasz D\u0142ugosz <tomek3d@gmail.com>'\n__docformat__ = 'restructuredtext en'\n\nimport re\nimport urllib\nfrom base64 import b64encode\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass LegimiStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        aff_root = 'https://www.a4b-tracking.com/pl/stat-click-text-link/9/58/'\n\n        url = 'http://www.legimi.com/pl/ebooki/'\n\n        aff_url = aff_root + str(b64encode(url))\n\n        detail_url = None\n        if detail_item:\n            detail_url = aff_root + str(b64encode(detail_item))\n\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner(detail_url if detail_url else aff_url)))\n        else:\n            d = WebStoreDialog(self.gui, url, parent, detail_url if detail_url else aff_url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=10, timeout=60):\n        url = 'http://www.legimi.com/pl/ebooki/?szukaj=' + urllib.quote_plus(query)\n\n        br = browser()\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n            for data in doc.xpath('//div[@id=\"listBooks\"]/div'):\n                if counter <= 0:\n                    break\n\n                id = ''.join(data.xpath('.//a[1]/@href'))\n                if not id:\n                    continue\n\n                cover_url = ''.join(data.xpath('.//img[1]/@src'))\n                title = ''.join(data.xpath('.//span[@class=\"bookListTitle ellipsis\"]/text()'))\n                author = ''.join(data.xpath('.//span[@class=\"bookListAuthor ellipsis\"]/text()'))\n                price = ''.join(data.xpath('.//div[@class=\"bookListPrice\"]/span/text()'))\n\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = 'http://www.legimi.com/' + cover_url\n                s.title = title.strip()\n                s.author = author.strip()\n                s.price = price\n                s.detail_item = 'http://www.legimi.com/' + id.strip()\n\n                yield s\n\n    def get_details(self, search_result, timeout):\n        drm_pattern = re.compile(\"zabezpieczona DRM\")\n        formats = []\n        br = browser()\n        with closing(br.open(search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            formatlist = idata.xpath('.//div[@id=\"fullBookFormats\"]//span[@class=\"bookFormat\"]/text()')\n            for x in formatlist:\n                if x.strip() not in formats:\n                    formats.append(x.strip())\n            drm = drm_pattern.search(''.join(idata.xpath('.//div[@id=\"fullBookFormats\"]/p/text()')))\n            search_result.formats = ', '.join(formats)\n            search_result.drm = SearchResult.DRM_LOCKED if drm else SearchResult.DRM_UNLOCKED\n        return True\n", 
  "ozon_ru": "\ufeff# -*- coding: utf-8 -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 2 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011-2013, Roman Mukhin <ramses_ru at hotmail.com>'\n__docformat__ = 'restructuredtext en'\n\nimport random\nimport re\nimport urllib2\n\nfrom contextlib import closing\nfrom lxml import etree, html\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.ebooks.chardet import xml_to_unicode\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass OzonRUStore(BasicStoreConfig, StorePlugin):\n    shop_url = 'http://www.ozon.ru'\n\n    def open(self, parent=None, detail_item=None, external=False):\n\n        aff_id = '?partner=romuk'\n        # Use Kovid's affiliate id 30% of the time.\n        if random.randint(1, 10) in (1, 2, 3):\n            aff_id = '?partner=kovidgoyal'\n\n        url = self.shop_url + aff_id\n        detail_url = None\n        if detail_item:\n            # http://www.ozon.ru/context/detail/id/3037277/\n            detail_url = self.shop_url + '/context/detail/id/' + urllib2.quote(detail_item) + aff_id\n\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner(detail_url if detail_url else url)))\n        else:\n            d = WebStoreDialog(self.gui, url, parent, detail_url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=15, timeout=60):\n        search_url = self.shop_url + '/webservice/webservice.asmx/SearchWebService?'\\\n                    'searchText=%s&searchContext=ebook' % urllib2.quote(query)\n        search_urls = [ search_url ]\n\n        xp_template = 'normalize-space(./*[local-name() = \"{0}\"]/text())'\n        counter = max_results\n        br = browser()\n\n        for url in search_urls:\n            with closing(br.open(url, timeout=timeout)) as f:\n                raw = xml_to_unicode(f.read(), strip_encoding_pats=True, assume_utf8=True)[0]\n                doc = etree.fromstring(raw)\n                for data in doc.xpath('//*[local-name()=\"SearchItems\" or local-name()=\"ItemDetail\"]'):\n                    if counter <= 0:\n                        break\n                    counter -= 1\n\n                    s = SearchResult()\n                    s.detail_item = data.xpath(xp_template.format('ID'))\n                    s.title = data.xpath(xp_template.format('Name'))\n                    s.author = data.xpath(xp_template.format('Author'))\n                    s.price = data.xpath(xp_template.format('Price'))\n                    s.cover_url = data.xpath(xp_template.format('Picture'))\n                    s.price = format_price_in_RUR(s.price)\n                    yield s\n\n    def get_details(self, search_result, timeout=60):\n        url = self.shop_url + '/context/detail/id/' + urllib2.quote(search_result.detail_item)\n        br = browser()\n\n        result = False\n        with closing(br.open(url, timeout=timeout)) as f:\n            raw = xml_to_unicode(f.read(), verbose=True)[0]\n            doc = html.fromstring(raw)\n\n            # example where we are going to find formats\n            # <div class=\"l\">\n            #     <p>\n            #         \u0414\u043e\u0441\u0442\u0443\u043f\u043d\u043e:\n            #    </p>\n            # </div>\n            # <div class=\"l\">\n            #     <p>.epub, .fb2.zip, .pdf</p>\n            # </div>\n            xpt = u'normalize-space(//div[contains(@id, \"saleBlock\")]//*[contains(normalize-space(text()), \"\u0414\u043e\u0441\u0442\u0443\u043f\")]/ancestor-or-self::div[1]/following-sibling::div[1]/*[1])'\n            formats = doc.xpath(xpt)\n            if formats:\n                result = True\n                search_result.drm = SearchResult.DRM_UNLOCKED\n                search_result.formats = ', '.join(_parse_ebook_formats(formats))\n                # unfortunately no direct links to download books (only buy link)\n                # search_result.downloads['BF2'] = self.shop_url + '/order/digitalorder.aspx?id=' + + urllib2.quote(search_result.detail_item)\n\n            #<p class=\"main-cost\"><span class=\"main\">215</span><span class=\"submain\">00</span> \u0440\u0443\u0431.</p>\n            #<span itemprop=\"price\" class=\"hidden\">215.00</span>\n            #<meta itemprop=\"priceCurrency\" content=\"RUR \" />\n\n            # if the price not in the search result (the ID search case)\n            if not search_result.price:\n                price = doc.xpath(u'normalize-space(//*[@itemprop=\"price\"]/text())')\n                search_result.price = format_price_in_RUR(price)\n\n        return result\n\ndef format_price_in_RUR(price):\n    '''\n    Try to format price according ru locale: '12 212,34 \u0440\u0443\u0431.'\n    @param price: price in format like 25.99\n    @return: formatted price if possible otherwise original value\n    @rtype: unicode\n    '''\n    if price and re.match(\"^\\d*?\\.\\d*?$\", price):\n        try:\n            price = u'{:,.2F} \u0440\u0443\u0431.'.format(float(price))\n            price = price.replace(',', ' ').replace('.', ',', 1)\n        except:\n            pass\n    return price\n\ndef _parse_ebook_formats(formatsStr):\n    '''\n    Creates a list with displayable names of the formats\n\n    :param formatsStr: string with comma separated book formats\n           as it provided by ozon.ru\n    :return: a list with displayable book formats\n    '''\n\n    formatsUnstruct = formatsStr.lower()\n    formats = []\n    if 'epub' in formatsUnstruct:\n        formats.append('ePub')\n    if 'pdf' in formatsUnstruct:\n        formats.append('PDF')\n    if 'fb2' in formatsUnstruct:\n        formats.append('FB2')\n    if 'rtf' in formatsUnstruct:\n        formats.append('RTF')\n    if 'txt' in formatsUnstruct:\n        formats.append('TXT')\n    if 'djvu' in formatsUnstruct:\n        formats.append('DjVu')\n    if 'doc' in formatsUnstruct:\n        formats.append('DOC')\n    return formats\n", 
  "publio": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 4 # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2012-2014, Tomasz D\u0142ugosz <tomek3d@gmail.com>'\n__docformat__ = 'restructuredtext en'\n\nimport urllib\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser, url_slash_cleaner\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.basic_config import BasicStoreConfig\nfrom calibre.gui2.store.search_result import SearchResult\nfrom calibre.gui2.store.web_store_dialog import WebStoreDialog\n\nclass PublioStore(BasicStoreConfig, StorePlugin):\n\n    def open(self, parent=None, detail_item=None, external=False):\n        google_analytics = '?utm_source=tdcalibre&utm_medium=calibre'\n        url = 'http://www.publio.pl/' + google_analytics\n\n        if external or self.config.get('open_external', False):\n            open_url(QUrl(url_slash_cleaner((detail_item + google_analytics) if detail_item else url)))\n        else:\n            d = WebStoreDialog(self.gui, url, parent, detail_item if detail_item else url)\n            d.setWindowTitle(self.name)\n            d.set_tags(self.config.get('tags', ''))\n            d.exec_()\n\n    def search(self, query, max_results=20, timeout=60):\n\n        br = browser()\n\n        counter = max_results\n        page = 1\n        while counter:\n            with closing(br.open('http://www.publio.pl/szukaj,strona' + str(page) + '.html?q=' + urllib.quote(query) + '&sections=EMAGAZINE&sections=MINIBOOK&sections=EBOOK', timeout=timeout)) as f:\n                doc = html.fromstring(f.read())\n                for data in doc.xpath('//div[@class=\"item\"]'):\n                    if counter <= 0:\n                        break\n\n                    id = ''.join(data.xpath('.//div[@class=\"img\"]/a/@href'))\n                    if not id:\n                        continue\n\n                    cover_url = ''.join(data.xpath('.//div[@class=\"img\"]/a/img/@data-original'))\n                    title = ''.join(data.xpath('.//div[@class=\"img\"]/a/@title'))\n                    title2 = ''.join(data.xpath('.//div[@class=\"desc\"]/h5//text()'))\n                    if title2:\n                        title = title + '. ' + title2\n                    if (''.join(data.xpath('./div[@class=\"desc\"]/div[@class=\"detailShortList\"]/div[last()]/span/text()')).strip() == \"Seria:\"):\n                        series = ''.join(data.xpath('./div[@class=\"desc\"]/div[@class=\"detailShortList\"]/div[last()]/a/@title'))\n                        title = title + ' (seria ' + series + ')'\n                    author = ', '.join(data.xpath('./div[@class=\"desc\"]/div[@class=\"detailShortList\"]/div[@class=\"row\"][1]/a/@title'))\n                    price = ''.join(data.xpath('.//div[@class=\"priceBox tk-museo-slab\"]/ins/text()'))\n                    if not price:\n                        price = ''.join(data.xpath('.//div[@class=\"priceBox tk-museo-slab\"]/text()')).strip()\n                    formats = ', '.join([x.strip() for x in data.xpath('.//div[@class=\"formats\"]/a/text()')])\n\n                    counter -= 1\n\n                    s = SearchResult()\n                    s.cover_url = 'http://www.publio.pl' + cover_url\n                    s.title = title.strip()\n                    s.author = author\n                    s.price = price\n                    s.detail_item = 'http://www.publio.pl' + id.strip()\n                    s.drm = SearchResult.DRM_LOCKED if 'DRM' in formats else SearchResult.DRM_UNLOCKED\n                    s.formats = formats.replace(' DRM','').strip()\n\n                    yield s\n                if not doc.xpath('boolean(//a[@class=\"next\"])'):\n                    break\n                page+=1\n", 
  "amazon_ca": "# -*-\n\nfrom __future__ import (unicode_literals, division, absolute_import, print_function)\nstore_version = 2  # Needed for dynamic plugin loading\n\n__license__ = 'GPL 3'\n__copyright__ = '2011, John Schember <john@nachtimwald.com>'\n__docformat__ = 'restructuredtext en'\n\nfrom contextlib import closing\n\nfrom lxml import html\n\nfrom PyQt4.Qt import QUrl\n\nfrom calibre import browser\nfrom calibre.gui2 import open_url\nfrom calibre.gui2.store import StorePlugin\nfrom calibre.gui2.store.search_result import SearchResult\n\nclass AmazonCAKindleStore(StorePlugin):\n    '''\n    For comments on the implementation, please see amazon_plugin.py\n    '''\n\n    search_url = 'http://www.amazon.ca/s/url=search-alias%3Ddigital-text&field-keywords='\n    details_url = 'http://amazon.ca/dp/'\n    drm_search_text = u'Simultaneous Device Usage'\n    drm_free_text = u'Unlimited'\n\n    def open(self, parent=None, detail_item=None, external=False):\n        #aff_id = {'tag': ''}\n        # Use Kovid's affiliate id 30% of the time.\n        # if random.randint(1, 10) in (1, 2, 3):\n        #    aff_id['tag'] = 'calibrebs-20'\n        # store_link = 'http://www.amazon.ca/Kindle-eBooks/b/?ie=UTF&node=1286228011&ref_=%(tag)s&ref=%(tag)s&tag=%(tag)s&linkCode=ur2&camp=1789&creative=390957' % aff_id\n        store_link = 'http://www.amazon.ca/ebooks-kindle/b/ref=sa_menu_kbo?ie=UTF8&node=2980423011'\n        if detail_item:\n            # aff_id['asin'] = detail_item\n            # store_link = 'http://www.amazon.ca/dp/%(asin)s/?tag=%(tag)s' % aff_id\n            store_link = 'http://www.amazon.ca/dp/' + detail_item + '/'\n        open_url(QUrl(store_link))\n\n    def search(self, query, max_results=10, timeout=60):\n        url = self.search_url + query.encode('ascii', 'backslashreplace').replace('%', '%25').replace('\\\\x', '%').replace(' ', '+')\n        br = browser()\n\n        counter = max_results\n        with closing(br.open(url, timeout=timeout)) as f:\n            doc = html.fromstring(f.read())\n\n            if doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"grid\")]'):\n                data_xpath = '//div[contains(@class, \"prod\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './/img[contains(@class, \"productImage\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            elif doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"ilresults\")]'):\n                data_xpath = '//li[(@class=\"ilo\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './div[@class = \"ilf\"]/a/img[contains(@class, \"ilo\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                # Results can be in a grid (table) or a column\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltL\") or contains(@class, \"rsltGridList\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            elif doc.xpath('//div[@id = \"atfResults\" and contains(@class, \"list\")]'):\n                data_xpath = '//div[contains(@class, \"prod\")]'\n                format_xpath = (\n                        './/ul[contains(@class, \"rsltL\")]'\n                        '//span[contains(@class, \"lrg\") and not(contains(@class, \"bld\"))]/text()')\n                asin_xpath = '@name'\n                cover_xpath = './/img[contains(@class, \"productImage\")]/@src'\n                title_xpath = './/h3[@class=\"newaps\"]/a//text()'\n                author_xpath = './/h3[@class=\"newaps\"]//span[contains(@class, \"reg\")]//text()'\n                price_xpath = (\n                        './/ul[contains(@class, \"rsltL\")]'\n                        '//span[contains(@class, \"lrg\") and contains(@class, \"bld\")]/text()')\n            else:\n                return\n\n            for data in doc.xpath(data_xpath):\n                if counter <= 0:\n                    break\n\n                # Even though we are searching digital-text only Amazon will still\n                # put in results for non Kindle books (author pages). Se we need\n                # to explicitly check if the item is a Kindle book and ignore it\n                # if it isn't.\n                format = ''.join(data.xpath(format_xpath))\n                if 'kindle' not in format.lower():\n                    continue\n\n                # We must have an asin otherwise we can't easily reference the\n                # book later.\n                asin = data.xpath(asin_xpath)\n                if asin:\n                    asin = asin[0]\n                else:\n                    continue\n\n                cover_url = ''.join(data.xpath(cover_xpath))\n\n                title = ''.join(data.xpath(title_xpath))\n                author = ''.join(data.xpath(author_xpath))\n                try:\n                    author = author.split('by ', 1)[1].split(\" (\")[0]\n                except:\n                    pass\n\n                price = ''.join(data.xpath(price_xpath))\n\n                counter -= 1\n\n                s = SearchResult()\n                s.cover_url = cover_url.strip()\n                s.title = title.strip()\n                s.author = author.strip()\n                s.price = price.strip()\n                s.detail_item = asin.strip()\n                s.formats = 'Kindle'\n\n                yield s\n\n    def get_details(self, search_result, timeout):\n        url = self.details_url\n\n        br = browser()\n        with closing(br.open(url + search_result.detail_item, timeout=timeout)) as nf:\n            idata = html.fromstring(nf.read())\n            if idata.xpath('boolean(//div[@class=\"content\"]//li/b[contains(text(), \"' +\n                           self.drm_search_text + '\")])'):\n                if idata.xpath('boolean(//div[@class=\"content\"]//li[contains(., \"' +\n                               self.drm_free_text + '\") and contains(b, \"' +\n                               self.drm_search_text + '\")])'):\n                    search_result.drm = SearchResult.DRM_UNLOCKED\n                else:\n                    search_result.drm = SearchResult.DRM_UNKNOWN\n            else:\n                search_result.drm = SearchResult.DRM_LOCKED\n        return True\n"
}